/**
 * 处理预览网页请求。
 * 如果是目录，则返回目录列表
 */

var fs        = require('fs')
    , path    = require('path')
    , join    = path.join
    , _       = require('underscore')
    , mime    = require('mime')
    , util    = require('util')
    , http    = require('http')
    , debug   = require('debug')('clam:jspage')
    , config  = require('./config.js')
    , compile = require('./compile.js')
    , proxy   = require("./proxy.js")
    , J       = require("juicer")
    , isUtf8  = require('is-utf8')
    , crypto  = require('crypto')
    , iconv   = require('iconv-lite')
    , urlLib  = require('url')
    , conf    = {
        "templateDir"      : "../ui/",
        "template": "folder-viewer.html"
    };
//var pathUtil = require('path');

/**
 * 传入参数option格式
 * {
 *    root: '/',
 *    mapping: {'/aaaa': ['aaa/bbb.html', 'ccc/aaa.html']},
 *    maxAge : 1000,
 *    charset : 'gbk',
 *    modsDir: [], //相对项目目录的模块目录位置，可以有多个
 * }
 */
exports = module.exports = function jspage(basePath) {
    basePath = basePath ? basePath : "src";
    var prjInfo = config.get('project');
    var root = config.root();
    var pageInfo = config.get('page');
    var mapping = {};
    _.each(pageInfo, function(value){
        mapping[value.url] = value.name;
    });
    debug('页面映射%s, \n %s', util.inspect(pageInfo), util.inspect(mapping));
    var modsDir = path.join(root, basePath);

    config.on('pageChange', function(){
        pageInfo = config.get('page');
        mapping = {};
        _.each(pageInfo, function(value){
            mapping[value.url] = value.name;
        });
        debug('page.json文件被修改:%s', util.inspect(mapping));
    });
    return function(req, res, next) {
        var URLParse = urlLib.parse(req.url);

        var url = URLParse.pathname;
        var pageRootPath = join(root, basePath);   // 页面根目录

        //请求的url真正相对页面根目录的路径。因为可以有目录映射。
        var realPageRelativePath = exports.mappedFile(url, pageRootPath, mapping);
        debug('页面请求%s -> %s', url.replace(/^[\/]/, ''), util.inspect(realPageRelativePath));
        //既不是文件。也不是目录
        if(!realPageRelativePath || realPageRelativePath === '') {
            if (!prjInfo.hostsMap || !prjInfo.hostsMap[req.headers.host]) {
                res.writeHead(404, { 'Content-Type': 'text/html;charset=utf-8'});
                res.end('404 Error, File not found.');
                return;
            }

            proxy.fetch(
                req.url,
                prjInfo.hostsMap ? prjInfo.hostsMap[req.headers.host] : '',
                function(content, code) {
                    if (code == 200) {
                        res.end(isUtf8(content) ? content.toString() : iconv.decode(content, 'gbk'));
                    }
                    else {
                        res.writeHead(code, { 'Content-Type': 'text/html;charset=utf-8'});
                        res.end(content);
                    }
                }
            );
            return;
        }
        //返回数组，表示是目录，需要显示目录。
        if(util.isArray(realPageRelativePath)){
            var files = realPageRelativePath.sort();
            debug('files', util.inspect(files));
            var tplPath = path.join(__dirname, conf.templateDir, conf.template);
            _.map(files, function(file){
                file.path = path.join(url, file.name);
                return file;
            })
            // this is using juicer engine only
            var pageContent = J(fs.readFileSync(tplPath).toString(), {folder : url, back: join(url, '..').replace(/\\/g, '/'), folderInfo:files});
            // this is using an include render and juicer 
            // var pageContent = J(compile.render(tplPath, [modsDir], prjInfo.cdnPath), {folderInfo: files});
            pageContent = new Buffer(pageContent);
            res.setHeader('Content-Type', 'text/html;charset=utf-8');
            res.setHeader('Content-Length', pageContent.length);
            res.end(pageContent);
            return;
        }
        //页面在服务器真实绝对路径
        var realAbsPapePath = join(pageRootPath, realPageRelativePath);
        //只处理html文件的SSI等高级语法
        if(realPageRelativePath.match(/.*\.html$/)){
            //html文件有片段和页面之分
            var rootContent = fs.readFileSync(realAbsPapePath);
            rootContent = isUtf8(rootContent) ? rootContent.toString() : iconv.decode(rootContent, 'gbk');

            var pageContent = '', tmsContent = [];
            try {
                pageContent = compile.render(realAbsPapePath, [modsDir], prjInfo.cdnPath, rootContent, url);
                // 解析assetsTool
                pageContent = compile.parseAssetsTool(pageContent);
            }
            catch(e) {
                console.log(util.inspect(e));
                res.writeHead(500, {'Content-Type' : 'text/html;charset=utf-8'});
                res.end('500 Error, Internal Server Error.');
                return;
            }

            var matches = pageContent.match(/(<!--#tms file=")(http:\/\/([^\:|\/]+)(\:\d*)?(.*\/)([^#|\?|\n]+)?(#.*)?(\?.*)?)("-->)/ig),
                m = [];
            matches = _.uniq(matches ? matches : []);
            for (var i=0; i<matches.length; i++) {
                m = matches[i].match(/(<!--#tms file=")(http:\/\/([^\:|\/]+)(\:\d*)?(.*\/)([^#|\?|\n]+)?(#.*)?(\?.*)?)("-->)/i);
                if (m && m[2] && m[3]) {
                    tmsContent.push(false);
                    proxy.fetch(
                        m[2],
                        m[3],
                        (function(i){
                            return function(content) {
                                tmsContent[i] = isUtf8(content) ? content.toString() : iconv.decode(content, 'gbk');
                                sendData();
                            }
                        })(i)
                    );
                }
            }

            var sendData = function() {
                for (var j = 0, len = matches.length; j < len; j++) {
                    if (tmsContent[j] === false) {
                        return;
                    }
                    else {
                        pageContent = pageContent.replace(new RegExp(matches[j], 'g'), tmsContent[j]);
                    }
                }
                if (!pageContent.match(/<\!DOCTYPE/)) {
                    pageContent = '<!DOCTYPE html>'+pageContent;
                }

                if(prjInfo.charset[0].match(/gbk/i)){
                    pageContent = iconv.encode(pageContent, 'gbk');
                }
                //输出前必须转换为Buffer，以便为Content-Length取得正确的length
                if (!(pageContent instanceof Buffer)) {
                    pageContent = new Buffer(pageContent);
                }
                res.setHeader('Content-Type', mime.lookup(realPageRelativePath) + '; charset=' + prjInfo.charset[0]);
                res.setHeader('Content-Length', pageContent.length);
                res.setHeader('Transfer-Encoding', 'chunked');
                res.end(pageContent);
            }
            sendData();
        }
        else {
            //其他格式的文件按照原内容返回
            var stream = fs.createReadStream(realAbsPapePath, {});
            req.on('close', stream.destroy.bind(stream));
            stream.pipe(res);

            stream.on('error', function(err){
                if (res.headerSent) {
                    req.destroy();
                } else {
                    next(err);
                }
            });
        }
    };
};

function parseToDir(maps){
    var virtualRoot = {};
    for(var k in maps){
        var currentObj = virtualRoot;
        var dirs = k.split('/');
        dirs[0] = '/';
        for(var i = 0, len = dirs.length; i < len; i++){
            var currentDir = currentObj[dirs[i]];
            if(!currentDir){
                currentObj[dirs[i]] = {};
            }
            currentObj = currentObj[dirs[i]];
        }
    }
    return virtualRoot;
}


/**
 * 根据url和映射关系返回对应真正的内容
 * 返回值有3种情况
 * 如果为null，则表示此url既不能对应到虚拟路径，也不能对应到实际路径。
 * 如果为字符串，则表示此url最终对应到一个文件。
 * 如果为数组，则表示此url最终对应到一个目录。
 * @param url
 * @param maps
 * @return {*}
 */
exports.mappedFile = function mappedFile(url, root, maps){
    var subDirs = [];
    debug('url:%s, map定义:%s',url, util.inspect(maps));
    
    //在表中定义过的映射,根据不同情况返回子目录或已存在内容的文件地址
    var mappedFile = maps[url];
    if(mappedFile){
        var mappedRealDir = join(root, mappedFile);
        var state = null;
        if(fs.existsSync(mappedRealDir)){
            state = fs.statSync(mappedRealDir);
            if(state.isDirectory()){
                subDirs = fs.readdirSync(mappedRealDir);
                subDirs = _.map(subDirs, function(subFile){
                    var state = fs.statSync(path.join(mappedRealDir, subFile));
                    return {name: subFile, isDir: state.isDirectory()};
                });
                return subDirs;
            }
            else{
                return mappedFile;
            }
        }
        else{
            return null;
        }
    }

    //寻找真实root目录下的相关文件，如果是目录，需要把目录的内容和映射定义中的合并起来
    var realDir = join(root, url);
    debug('寻找物理目录:%s', realDir);
    if (realDir.match(/.htm$/) && !fs.existsSync(realDir)) {
        realDir += 'l';
    }
    if(fs.existsSync(realDir)){
        var state = fs.statSync(realDir);
        if(!state.isDirectory()){
            return path.relative(root, realDir);
        }

        //寻找子目录
        var realsubDirs = fs.readdirSync(realDir);
        realsubDirs = _.map(realsubDirs, function(subFile){
            var state = fs.statSync(path.join(realDir, subFile));
            return {name: subFile, isDir: state.isDirectory()};
        });
        subDirs = subDirs.concat(realsubDirs);
    }

    //不是表定义中的映射，url有可能是定义映射key的一部分
    var virtual = parseToDir(maps);

    var currentVirtual = null;
    debug('url is : %s',url);
    var dirs = url.split('/');
    dirs[0] = '/';
    debug(util.inspect(dirs));
    for (var i = 0; i < dirs.length; i++) {
        if(dirs[i] === '') continue;
        if(virtual[dirs[i]]){
            virtual = virtual[dirs[i]];
            currentVirtual = virtual;
        }
        else{
            currentVirtual = null;
            break;
        }
    };
    debug('虚拟目录%s', util.inspect(currentVirtual));
    if(currentVirtual){
        for(var subPath in currentVirtual){
            var isDir = false;
            for(var subSubPath in currentVirtual[subPath]){
                isDir = true;
                break;
            }
            var subPathMapping = maps[path.join(url, subPath)];
            if(subPathMapping){
                subPathMapping = path.join(root, subPathMapping);
                if(fs.existsSync(subPathMapping)){
                    state = fs.statSync(subPathMapping);
                    if(state.isDirectory()){
                        isDir = true;
                    }
                }
            }
            var exist = _.find(subDirs, function(ss){
                return ss.name === subPath;
            });
            if(!exist){
                subDirs.push({name: subPath, isDir: isDir});
            }
        }
        
    }
    if (subDirs.length !== 0){
        return subDirs;
    }

    var longestMatchedKey = '';
    for(var j = 0; j < i; j++){
        longestMatchedKey = path.join(longestMatchedKey, dirs[j]);
    }
    debug('最长匹配路径转换后key%s', longestMatchedKey);
    if(maps[longestMatchedKey]){
        var lastPath = url.replace(longestMatchedKey, '');
        var longestMatchedPath = path.join(root, maps[longestMatchedKey], lastPath);
        debug('最长匹配路径转换后%s', longestMatchedPath);
        if(fs.existsSync(longestMatchedPath)){
            var longgestMatchedState = fs.statSync(longestMatchedPath);
            if(longgestMatchedState.isDirectory()){
                var longgestMatchedSubDirs = fs.readdirSync(longestMatchedPath);
                longgestMatchedSubDirs = _.map(longgestMatchedSubDirs, function(subFile){
                    var state = fs.statSync(path.join(longestMatchedPath, subFile));
                    return {name: subFile, isDir: state.isDirectory()};
                });
                return longgestMatchedSubDirs;
            }
            else{
                return path.join(maps[longestMatchedKey], lastPath);
            }
        }
        else{
            return null;
        }
    }
}
