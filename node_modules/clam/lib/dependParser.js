/**
 * @fileOverview FeLoader - KISSY模块依赖关系解析器.
 *
 * @author zhuofeng.ls@tmall.com dafeng.xdf@taobao.com
 *
 */
var debug = require('debug')('clam:dependParser');
var config = require('./config.js');
var assetsConfig = require('./assetsConfig.js').config;
var path = require('path');
var _ = require('underscore');

var gconfig = config.get('gconfig');

var hasLoadMod = {};

/**
 * config merge
 */
if(assetsConfig !={}){
    if(gconfig){
        gconfig['modules'] = _.extend(gconfig['modules'], assetsConfig['modules']);
        gconfig['packages'] = _.extend(gconfig['packages'], assetsConfig['packages']);
    }else {
        gconfig = assetsConfig;
    }
}

var modules = gconfig.modules,
    packages = gconfig.packages;

function getPackage(mod) {
    if (!mod) return;

    var pkg, max = 0, l;
    for (var prop in packages) {
        if (mod.indexOf(prop) === 0) {
            l = prop.length;

            // 贪婪式匹配
            if (l > max) {
                pkg = packages[prop];
                pkg.name = prop; // 补充name字段

                max = l;
            }
        }
    }

    // kissy的默认包的情况
    if (!pkg) {
        pkg = packages['default'];
        pkg.name = 'default';
    }

    return pkg;
}

function recurse(mods, obj) {
    var len;
    if (!mods || !(len = mods.length))
        return;

    !obj && (obj = {});
    for (var i = 0, mod, cfg; i < len; i++) {

        mod = mods[i];

        cfg = modules[mod] || {};

        //recurse(cfg['requires'], obj);

        var pkg = getPackage(mod),
            path = cfg['path'];

        if (pkg['ignorePackageNameInUri']) {
            if (!path) {
                path = mod.replace(pkg.name + '/', '') + (/\S*.(css|js)/g.test(mod) ? '' : '.js') ;
            }
        } else {
            if (!path) {
                path = mod + (/\S*.(css|js)/g.test(mod) ? '' : '.js');
            }
        }

        obj[mod] = {
            path: path, // TODO 1.需修正无path情况；2.修正basePath+path
            pkg: pkg,
            baseURI: pkg.path,
            fullPath: pkg.path + path
        }
    }

    return obj;
}

// 提取最长公共子串（Longest Common Substring）
function getLCString(aStr, bStr) {
    var len = aStr.length < bStr.length ? aStr.length : bStr.length,
        max = -1;

    for (var i = 0; i < len; i++) {
        if (aStr.charAt(i) == bStr.charAt(i) && i - max == 1) {
            max = i;
        } else {
            break;
        }
    }
    return aStr.substring(0, max + 1);
}

// 生成Combo urls | 这行内容适合提取到配置文件中
var comboPrefix = '??', comboSep = ',', maxUrlLength = 1024, maxFileNum = 20;
function getComboUrls(obj) {
    var lCString = '', paths = [], path;

    for (var k in obj) {
        if (obj.hasOwnProperty(k) && !(k in hasLoadMod)) {
            paths.push(path = obj[k].fullPath);

            if (lCString) {
                lCString = getLCString(path, lCString);
            } else {
                lCString = path;
            }
            hasLoadMod[k] = true;
        }
    }

    var num, start = 0, url, comboUrls = [], baseURI = paths.length > 1 ? lCString + comboPrefix : lCString;

    while (start < paths.length) {
        num = maxFileNum;
        do {
            url = baseURI + paths.slice(start, num).join(comboSep).replace(new RegExp(lCString,'g'), ''); // TODO 时间戳...
        } while ((url.length > maxUrlLength) && (num--));
        comboUrls.push(url);
        start = num;
    }

    return comboUrls;
}

var parser = {
    getComboUrls: function (content) {
        var mods = this.getMods(content), len = mods.length;

        if (!len)
            return '';

        var obj = recurse(mods); // 利用对象的KV特征自动去重
        return getComboUrls(obj);
    },

    getMods: function (content) {
        if (!content)
            return [];
        return content instanceof Array ?
            content:
            content.split(',');

    },

    clear: function() {
        hasLoadMod = {};   // 页面刷新时需要清楚记录的模块
    }
};

exports.parser = parser;
